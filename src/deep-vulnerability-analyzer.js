import 'dotenv/config';

// CONFIRMED VULNERABLE TARGETS from your simple analysis
const CONFIRMED_TARGETS = [
  {
    name: 'Reserve Protocol - ERC4626 Collateral',
    url: 'https://github.com/reserve-protocol/protocol/blob/73362259c5a14c9c7bf3db0bd64fd9d1d370568a/contracts/plugins/assets/ERC4626FiatCollateral.sol',
    risk: 'HIGH',
    patternsFound: ['HIGH: pricePerShare/convertToAssets calls', 'MEDIUM: 10 ERC4626 patterns']
  },
  {
    name: 'Curvance - CTokenPrimitive', 
    url: 'https://github.com/curvance/Curvance-CantinaCompetition/blob/76669e36572d9c6803a0e706214a9149d5247586/contracts/market/collateral/CTokenPrimitive.sol',
    risk: 'MEDIUM',
    patternsFound: ['MEDIUM: ERC4626 collateral integration']
  },
  {
    name: 'Sturdy Finance - ERC4626 Vault',
    url: 'https://github.com/sturdyfi/sturdy-contracts/blob/944dc537195413c4adc65a6f00cc80344b0f5ba4/contracts/protocol/vault/ERC4626/ERC4626Vault.sol',
    risk: 'MEDIUM_HIGH', 
    patternsFound: ['MEDIUM: 8 ERC4626 vault patterns']
  },
  {
    name: 'Timeless Fi - AaveV2 ERC4626 Wrapper',
    url: 'https://github.com/timeless-fi/yield-daddy/blob/8b8761035f4874550679bf13f427c539594947f5/src/aave-v2/AaveV2ERC4626.sol',
    risk: 'MEDIUM',
    patternsFound: ['MEDIUM: 9 ERC4626 wrapper patterns']
  }
];

console.log('ðŸ” DEEP VULNERABILITY ANALYSIS - PHASE 3');
console.log('='.repeat(70));
console.log('Performing deep analysis on CONFIRMED vulnerable targets...\n');

async function deepAnalyzeTargets() {
  const detailedResults = [];
  
  for (const target of CONFIRMED_TARGETS) {
    console.log(`ðŸŽ¯ DEEP ANALYZING: ${target.name}`);
    console.log(`   ðŸ”— ${target.url}`);
    console.log(`   âš ï¸  Risk Level: ${target.risk}`);
    
    try {
      const rawUrl = target.url
        .replace('github.com', 'raw.githubusercontent.com')
        .replace('/blob/', '/');
      
      const response = await fetch(rawUrl);
      const content = await response.text();
      
      const analysis = await analyzeVulnerabilityDetails(content, target.name);
      detailedResults.push({ ...target, analysis });
      
      console.log(`   ðŸ“Š Analysis Complete:`);
      console.log(`      ðŸ” Total Lines: ${content.split('\n').length}`);
      console.log(`      ðŸ’€ Critical Findings: ${analysis.critical.length}`);
      console.log(`      âš ï¸  High Findings: ${analysis.high.length}`);
      console.log(`      ðŸ“‹ Integration Points: ${analysis.integrationPoints.length}`);
      
      if (analysis.critical.length > 0) {
        console.log(`      ðŸš¨ CRITICAL VULNERABILITIES FOUND!`);
        analysis.critical.forEach((vuln, idx) => {
          console.log(`         ${idx + 1}. ${vuln.type}: ${vuln.description}`);
        });
      }
      
    } catch (error) {
      console.log(`   âŒ Analysis failed: ${error.message}`);
    }
    
    console.log('   '.padEnd(50, 'â”€'));
    await new Promise(resolve => setTimeout(resolve, 1500));
  }
  
  generateDeepAnalysisReport(detailedResults);
}

async function analyzeVulnerabilityDetails(content, targetName) {
  const analysis = {
    critical: [],
    high: [],
    medium: [],
    integrationPoints: []
  };

  // CRITICAL: Direct vulnerable patterns
  const criticalPatterns = [
    {
      pattern: /(totalAssets\s*\(\s*\)\s*\/\s*totalSupply\s*\(\s*\)|totalAssets\s*\/\s*totalSupply)/,
      type: 'Donation-Attack-Vulnerability',
      description: 'Direct totalAssets/totalSupply calculation - vulnerable to inflation attacks',
      severity: 'CRITICAL'
    },
    {
      pattern: /(pricePerShare\s*=\s*totalAssets\s*\/\s*totalSupply|exchangeRate\s*=\s*totalSupply)/,
      type: 'Price-Manipulation-Vulnerability', 
      description: 'Direct price calculation without protection - can be manipulated',
      severity: 'CRITICAL'
    }
  ];

  // HIGH: Dangerous integration patterns
  const highPatterns = [
    {
      pattern: /(\.pricePerShare\(\)|\.convertToAssets\()/,
      type: 'Direct-Vault-Price-Call',
      description: 'Direct call to vault price functions - needs validation',
      severity: 'HIGH'
    },
    {
      pattern: /(getCollateralValue.*vault|getValue.*vault|_getVaultValue)/,
      type: 'Vault-Collateral-Valuation',
      description: 'Vault collateral valuation function - check for safe math',
      severity: 'HIGH'
    }
  ];

  // MEDIUM: Integration points to review
  const mediumPatterns = [
    {
      pattern: /(ERC4626|IERC4626)/,
      type: 'ERC4626-Interface-Usage',
      description: 'ERC4626 interface integration - review implementation',
      severity: 'MEDIUM'
    },
    {
      pattern: /(vault|Vault)/,
      type: 'Vault-Integration',
      description: 'Vault integration point - check for proper validation',
      severity: 'MEDIUM'
    }
  ];

  // Analyze content for each pattern type
  for (const pattern of criticalPatterns) {
    const matches = content.match(new RegExp(pattern.pattern, 'g'));
    if (matches) {
      analysis.critical.push({
        ...pattern,
        count: matches.length,
        examples: getCodeExamples(content, pattern.pattern)
      });
    }
  }

  for (const pattern of highPatterns) {
    const matches = content.match(new RegExp(pattern.pattern, 'g'));
    if (matches) {
      analysis.high.push({
        ...pattern,
        count: matches.length,
        examples: getCodeExamples(content, pattern.pattern)
      });
    }
  }

  for (const pattern of mediumPatterns) {
    const matches = content.match(new RegExp(pattern.pattern, 'g'));
    if (matches) {
      analysis.medium.push({
        ...pattern,
        count: matches.length
      });
    }
  }

  // Extract integration points for manual review
  analysis.integrationPoints = extractIntegrationPoints(content);

  return analysis;
}

function getCodeExamples(content, pattern, exampleCount = 2) {
  const lines = content.split('\n');
  const examples = [];
  
  for (let i = 0; i < lines.length && examples.length < exampleCount; i++) {
    if (new RegExp(pattern).test(lines[i])) {
      const start = Math.max(0, i - 1);
      const end = Math.min(lines.length, i + 2);
      examples.push(lines.slice(start, end).join(' | '));
    }
  }
  
  return examples;
}

function extractIntegrationPoints(content) {
  const integrationPoints = [];
  const lines = content.split('\n');
  
  // Look for function definitions that might be integration points
  const integrationPatterns = [
    /function.*price.*\(/,
    /function.*value.*\(/,
    /function.*collateral.*\(/,
    /function.*convert.*\(/,
    /function.*share.*\(/,
    /function.*asset.*\(/
  ];
  
  for (let i = 0; i < lines.length; i++) {
    for (const pattern of integrationPatterns) {
      if (pattern.test(lines[i])) {
        integrationPoints.push({
          line: i + 1,
          function: lines[i].trim(),
          context: lines.slice(Math.max(0, i - 1), Math.min(lines.length, i + 3)).join(' | ')
        });
        break;
      }
    }
  }
  
  return integrationPoints;
}

function generateDeepAnalysisReport(results) {
  console.log('\n' + '='.repeat(80));
  console.log('ðŸŽ¯ DEEP VULNERABILITY ANALYSIS REPORT - PHASE 3');
  console.log('='.repeat(80));

  const criticalTargets = results.filter(r => r.analysis.critical.length > 0);
  const highTargets = results.filter(r => r.analysis.high.length > 0);
  
  console.log(`\nðŸ“Š DEEP ANALYSIS SUMMARY:`);
  console.log(`   Total targets analyzed: ${results.length}`);
  console.log(`   Targets with CRITICAL vulnerabilities: ${criticalTargets.length}`);
  console.log(`   Targets with HIGH risk patterns: ${highTargets.length}`);

  if (criticalTargets.length > 0) {
    console.log('\nðŸš¨ IMMEDIATE ACTION REQUIRED - CRITICAL VULNERABILITIES:');
    console.log('â”€'.repeat(70));
    
    criticalTargets.forEach((target, index) => {
      console.log(`\n${index + 1}. ${target.name}`);
      console.log(`   ðŸ”— ${target.url}`);
      console.log(`   ðŸ’€ CRITICAL VULNERABILITIES:`);
      
      target.analysis.critical.forEach((vuln, vulnIndex) => {
        console.log(`      ${vulnIndex + 1}. ${vuln.type}`);
        console.log(`         ðŸ“ ${vuln.description}`);
        console.log(`         ðŸ”¢ Found ${vuln.count} instances`);
        if (vuln.examples && vuln.examples.length > 0) {
          console.log(`         ðŸ“„ Example: ${vuln.examples[0].slice(0, 100)}...`);
        }
      });
    });

    console.log('\nðŸ’¼ SECURITY BUSINESS OPPORTUNITY CONFIRMED!');
    console.log(`   ðŸŽ¯ You have ${criticalTargets.length} projects with CRITICAL vulnerabilities`);
    console.log(`   ðŸ’° These are high-value targets for security audits`);
    console.log(`   ðŸ“§ Consider responsible disclosure or security service offers`);
    
  } else if (highTargets.length > 0) {
    console.log('\nâš ï¸ HIGH PRIORITY TARGETS FOUND:');
    highTargets.forEach(target => {
      console.log(`   ðŸ“ ${target.name} - ${target.analysis.high.length} high-risk patterns`);
    });
    console.log('\nðŸ’¡ These need security review and potential audit services');
    
  } else {
    console.log('\nðŸ“‹ INTEGRATION POINTS IDENTIFIED:');
    results.forEach(target => {
      console.log(`   ðŸ“„ ${target.name} - ${target.analysis.integrationPoints.length} integration points`);
    });
    console.log('\nðŸ’¡ Manual code review recommended for these integration points');
  }

  console.log('\nðŸŽ¯ NEXT STEPS:');
  console.log('   1. Contact projects with CRITICAL vulnerabilities for security audits');
  console.log('   2. Prepare proof-of-concept exploits for demonstration');
  console.log('   3. Consider responsible disclosure process');
  console.log('   4. Offer security review services for HIGH risk targets');
}

// Run the deep analysis
deepAnalyzeTargets().catch(console.error);
