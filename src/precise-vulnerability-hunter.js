import 'dotenv/config';
import { Octokit } from '@octokit/rest';
import fs from 'fs';
import path from 'path';

const octokit = new Octokit({ 
  auth: process.env.GITHUB_TOKEN
});

// PRECISE vulnerability patterns - only flag ACTUAL dangerous code
const PRECISE_VULNERABILITY_PATTERNS = {
  ERC4626_DONATION_ATTACK: [
    // Direct vulnerable pricePerShare implementations
    /function\s+pricePerShare\s*\(\s*\)\s*public\s+view\s+returns\s*\(\s*uint256\s*\)\s*\{[^}]*totalAssets\s*\/\s*totalSupply[^}]*\}/,
    /function\s+convertToAssets\s*\(\s*uint256\s+shares\s*\)\s*public\s+view\s+returns\s*\(\s*uint256\s*\)\s*\{[^}]*shares\s*\*\s*totalAssets\s*\(\s*\)\s*\/\s*totalSupply\s*\(\s*\)[^}]*\}/,
    /return\s+totalAssets\s*\(\s*\)\s*\.mul\s*\(\s*1e18\s*\)\s*\.div\s*\(\s*totalSupply\s*\(\s*\)\s*\)/,
    // No virtual shares protection
    /function\s+(pricePerShare|convertToAssets|convertToShares).*\{[^}]*?(totalAssets\s*\/\s*totalSupply|totalAssets\s*\(\s*\)\s*\/\s*totalSupply\s*\(\s*\))[^}]*\}(?!.*virtualShares)(?!.*_initialShareAmount)(?!.*10\*\*_decimalsOffset)/s
  ],
  
  SHARE_PRICE_MANIPULATION: [
    // Compound/Aave style exchange rate vulnerabilities
    /function\s+exchangeRateCurrent\s*\(\s*\)\s*.*returns\s*\(\s*uint256\s*\)\s*\{[^}]*totalSupply\s*[^}]*\}/,
    /function\s+getExchangeRate\s*\(\s*\)\s*public\s+view\s+returns\s*\(\s*uint256\s*\)\s*\{[^}]*totalSupply\s*[^}]*\}/,
    /exchangeRate\s*=\s*totalSupply\s*==\s*0\s*\?\s*initialExchangeRate\s*:\s*totalAssets\s*\/\s*totalSupply/
  ],
  
  // Specific known vulnerable protocols to target
  KNOWN_VULNERABLE_PROTOCOLS: [
    'ResupplyFi/cvcrvUSD',
    'Warren-Finance/warren-contracts', 
    'sentimentxyz/orca',
    'yieldprotocol/yieldspace-tv',
    'fei-protocol/fuse-flywheel',
    'Rari-Capital/solmate',
    'IndexCoop/index-coop-smart-contracts'
  ]
};

class PreciseVulnerabilityHunter {
  constructor() {
    this.realVulnerabilities = [];
    this.scannedCount = 0;
  }

  async huntRealVulnerabilities() {
    console.log('ğŸ¯ PRECISE VULNERABILITY HUNTER - FINDING REAL EXPLOITS');
    console.log('='.repeat(70));
    
    // Strategy 1: Search for specific vulnerable code patterns across GitHub
    await this.searchVulnerableCodePatterns();
    
    // Strategy 2: Check forks of KNOWN exploited protocols
    await this.checkKnownVulnerableForks();
    
    // Strategy 3: Search for specific ERC4626 implementations
    await this.huntERC4626Vaults();
    
    this.generateRealFindingsReport();
  }

  async searchVulnerableCodePatterns() {
    console.log('\nğŸ” STRATEGY 1: Searching for specific vulnerable code patterns...');
    
    const searchQueries = [
      'totalAssets+/+totalSupply+language:Solidity',
      'pricePerShare+totalAssets+language:Solidity', 
      'convertToAssets+totalSupply+language:Solidity',
      'exchangeRate+totalSupply+language:Solidity',
      'ERC4626+pricePerShare+language:Solidity',
      'vault+donation+attack+language:Solidity'
    ];

    for (const query of searchQueries.slice(0, 3)) { // Limit to avoid rate limits
      console.log(`   Searching: "${query}"`);
      
      try {
        const { data } = await octokit.rest.search.code({
          q: query,
          per_page: 30
        });

        console.log(`   Found ${data.total_count} potential matches`);

        for (const item of data.items.slice(0, 10)) {
          await this.analyzeCodeItem(item);
          await this.delay(500); // Rate limiting
        }
      } catch (error) {
        console.log(`   âŒ Search failed: ${error.message}`);
      }
    }
  }

  async checkKnownVulnerableForks() {
    console.log('\nğŸ” STRATEGY 2: Checking forks of KNOWN exploited protocols...');
    
    for (const protocol of PRECISE_VULNERABILITY_PATTERNS.KNOWN_VULNERABLE_PROTOCOLS) {
      const [owner, repo] = protocol.split('/');
      console.log(`   Checking forks of: ${protocol}`);
      
      try {
        const { data: forks } = await octokit.rest.repos.listForks({
          owner,
          repo,
          per_page: 20,
          sort: 'updated'
        });

        for (const fork of forks) {
          if (this.scannedCount >= 50) break; // Limit total scans
          
          console.log(`      ğŸ” ${fork.full_name}`);
          const hasVulns = await this.deepScanRepository(fork.owner.login, fork.name);
          
          if (hasVulns) {
            this.realVulnerabilities.push({
              repository: fork.full_name,
              url: fork.html_url,
              source: 'KnownVulnerableProtocol',
              confirmed: true,
              risk: 'HIGH'
            });
          }
          
          this.scannedCount++;
          await this.delay(800);
        }
      } catch (error) {
        console.log(`      âŒ Cannot access ${protocol}: ${error.message}`);
      }
    }
  }

  async huntERC4626Vaults() {
    console.log('\nğŸ” STRATEGY 3: Hunting for custom ERC4626 vault implementations...');
    
    const erc4626Queries = [
      'ERC4626.sol+language:Solidity',
      'extends+ERC4626+language:Solidity', 
      'import+.*ERC4626+language:Solidity',
      'vault+ERC4626+language:Solidity'
    ];

    for (const query of erc4626Queries.slice(0, 2)) {
      console.log(`   Searching: "${query}"`);
      
      try {
        const { data } = await octokit.rest.search.code({
          q: query,
          per_page: 20
        });

        for (const item of data.items.slice(0, 10)) {
          await this.analyzeERC4626Implementation(item);
          await this.delay(600);
        }
      } catch (error) {
        console.log(`   âŒ Search failed: ${error.message}`);
      }
    }
  }

  async deepScanRepository(owner, repo) {
    try {
      // Get all Solidity files
      const solidityFiles = await this.getSolidityFiles(owner, repo);
      
      for (const file of solidityFiles.slice(0, 15)) { // Check first 15 files
        const vulnerabilities = await this.scanFileForPreciseVulnerabilities(owner, repo, file);
        if (vulnerabilities.length > 0) {
          console.log(`         ğŸ’€ VULNERABLE: Found ${vulnerabilities.length} issues in ${file.name}`);
          return true;
        }
      }
    } catch (error) {
      // Skip if we can't scan
    }
    
    return false;
  }

  async scanFileForPreciseVulnerabilities(owner, repo, file) {
    const vulnerabilities = [];
    
    try {
      const { data: fileContent } = await octokit.rest.repos.getContent({
        owner,
        repo,
        path: file.path
      });

      const content = Buffer.from(fileContent.content, 'base64').toString('utf8');
      
      // Check each precise pattern
      for (const [vulnType, patterns] of Object.entries(PRECISE_VULNERABILITY_PATTERNS)) {
        for (const pattern of patterns) {
          if (pattern.test(content)) {
            vulnerabilities.push({
              type: vulnType,
              file: file.name,
              pattern: pattern.toString().slice(0, 100),
              confirmed: true
            });
          }
        }
      }
    } catch (error) {
      // Skip file if we can't read it
    }
    
    return vulnerabilities;
  }

  async getSolidityFiles(owner, repo, path = '') {
    let files = [];
    
    try {
      const { data: contents } = await octokit.rest.repos.getContent({
        owner,
        repo,
        path: path || ''
      });

      for (const item of contents) {
        if (item.type === 'file' && item.name.endsWith('.sol')) {
          files.push({
            path: item.path,
            name: item.name,
            size: item.size
          });
        } else if (item.type === 'dir') {
          // Limit recursion depth
          if (path.split('/').length < 2) {
            const subFiles = await this.getSolidityFiles(owner, repo, item.path);
            files.push(...subFiles);
          }
        }
      }
    } catch (error) {
      // Can't access directory
    }
    
    return files;
  }

  async analyzeCodeItem(item) {
    try {
      const { data: fileContent } = await octokit.rest.repos.getContent({
        owner: item.repository.owner.login,
        repo: item.repository.name,
        path: item.path
      });

      const content = Buffer.from(fileContent.content, 'base64').toString('utf8');
      
      // Check for precise vulnerabilities
      for (const [vulnType, patterns] of Object.entries(PRECISE_VULNERABILITY_PATTERNS)) {
        for (const pattern of patterns) {
          if (pattern.test(content)) {
            console.log(`         ğŸ’€ FOUND REAL VULNERABILITY in ${item.repository.full_name}`);
            this.realVulnerabilities.push({
              repository: item.repository.full_name,
              url: item.html_url,
              type: vulnType,
              file: item.name,
              confirmed: true,
              risk: 'CRITICAL',
              pattern: pattern.toString().slice(0, 80)
            });
            return;
          }
        }
      }
    } catch (error) {
      // Skip if we can't analyze
    }
  }

  async analyzeERC4626Implementation(item) {
    // Similar to analyzeCodeItem but focused on ERC4626
    await this.analyzeCodeItem(item);
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  generateRealFindingsReport() {
    console.log('\n' + '='.repeat(80));
    console.log('ğŸ¯ PRECISE VULNERABILITY HUNTING REPORT');
    console.log('='.repeat(80));

    if (this.realVulnerabilities.length === 0) {
      console.log('\nâŒ NO REAL VULNERABILITIES FOUND WITH PRECISE MATCHING');
      console.log('ğŸ’¡ The vulnerable patterns might be more subtle than expected.');
      console.log('ğŸš€ We need to try EVEN MORE AGGRESSIVE hunting strategies...');
      return;
    }

    console.log(`\nğŸš¨ FOUND ${this.realVulnerabilities.length} REAL VULNERABILITIES!`);
    console.log('â”€'.repeat(60));

    this.realVulnerabilities.forEach((vuln, index) => {
      console.log(`\n${index + 1}. ${vuln.repository}`);
      console.log(`   ğŸ”— ${vuln.url}`);
      console.log(`   ğŸ’€ Type: ${vuln.type}`);
      console.log(`   ğŸ“„ File: ${vuln.file}`);
      console.log(`   ï¿½ï¿½ Status: ${vuln.confirmed ? 'CONFIRMED' : 'SUSPECTED'}`);
      console.log(`   âš ï¸  Risk: ${vuln.risk}`);
    });

    // Save findings
    const report = {
      huntDate: new Date().toISOString(),
      vulnerabilitiesFound: this.realVulnerabilities.length,
      realVulnerabilities: this.realVulnerabilities,
      scannedCount: this.scannedCount
    };

    if (!fs.existsSync('results/precise-hunt')) {
      fs.mkdirSync('results/precise-hunt', { recursive: true });
    }

    const reportFile = `results/precise-hunt/real-vulnerabilities-${Date.now()}.json`;
    fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));

    console.log(`\nğŸ“„ Detailed report saved to: ${reportFile}`);
    
    console.log('\nğŸ¯ NEXT STEPS:');
    console.log('   1. Manually verify these CONFIRMED vulnerabilities');
    console.log('   2. Check if they are deployed on mainnet');
    console.log('   3. Prepare exploit simulations');
    console.log('   4. Consider responsible disclosure');
  }
}

// Run the precise hunter
const hunter = new PreciseVulnerabilityHunter();
hunter.huntRealVulnerabilities().catch(console.error);
